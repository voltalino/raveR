% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/live.R
\name{PlaybackController}
\alias{PlaybackController}
\title{PlaybackController Class}
\description{
An R6 class that manages continuous audio playback with pre-rendered buffers.
Uses later::later() for non-blocking scheduling and tracks playback state
including bar position and pending transitions.
}
\details{
The controller generates 4-bar audio buffers (approximately 8 seconds at 120 BPM),
which provides enough lookahead time to generate the next buffer while the
current one plays. This approach handles R's GC pauses gracefully.

Key features:
\itemize{
\item Non-blocking playback with later::later() scheduling
\item 4-bar buffer generation using raver_compose_section()
\item State tracking for bar position and transitions
\item Graceful error handling with last_known_good_model fallback
\item Pending transition flag for smooth phrase-boundary changes
}
}
\section{Public fields}{
\if{html}{\out{<div class="r6-fields">}}
\describe{
\item{\code{script_path}}{Path to the R script being played}

\item{\code{code_model}}{Current CodeModel from script analysis}

\item{\code{bpm}}{Beats per minute (118-124 range for deep house)}

\item{\code{is_playing}}{Whether playback is currently active}

\item{\code{current_bar}}{Current bar position in playback (0-indexed)}

\item{\code{pending_transition}}{Whether a transition is queued for next phrase}

\item{\code{last_known_good_model}}{Last successfully parsed CodeModel for fallback}

\item{\code{has_parse_error}}{Whether the current script has a parse error}

\item{\code{genre}}{Music genre for playback}

\item{\code{max_buffer_seconds}}{Maximum buffer size to prevent memory leaks}

\item{\code{buffer_history}}{Ring buffer of recent audio buffers (for memory management)
Initialize PlaybackController}

\item{\code{buffer_queue}}{List of pre-rendered Wave objects awaiting playback}

\item{\code{current_instance}}{Current audioInstance from play_audio()}

\item{\code{later_handle}}{Handle to cancel pending generation callbacks}

\item{\code{playback_handle}}{Handle to cancel pending playback callbacks}

\item{\code{file_watcher}}{Watcher object for script file monitoring}

\item{\code{fade_samples}}{Number of samples for crossfade (50ms at 44100Hz)}

\item{\code{loop_bars}}{Number of bars per loop (longer = fewer switches)}

\item{\code{current_buffer}}{Current playing buffer for seamless re-looping}

\item{\code{next_buffer}}{Pre-generated buffer for after transition}

\item{\code{section_cycle}}{Section types to cycle through for variety}

\item{\code{current_section_idx}}{Current position in section cycle
Manage buffer memory (prevent leaks)

Adds buffer to history and prunes old buffers to stay under max_buffer_seconds}
}
\if{html}{\out{</div>}}
}
\section{Active bindings}{
\if{html}{\out{<div class="r6-active-bindings">}}
\describe{
\item{\code{buffer_queue}}{List of pre-rendered Wave objects awaiting playback}

\item{\code{current_instance}}{Current audioInstance from play_audio()}

\item{\code{later_handle}}{Handle to cancel pending generation callbacks}

\item{\code{playback_handle}}{Handle to cancel pending playback callbacks}

\item{\code{file_watcher}}{Watcher object for script file monitoring}

\item{\code{fade_samples}}{Number of samples for crossfade (50ms at 44100Hz)}

\item{\code{loop_bars}}{Number of bars per loop (longer = fewer switches)}

\item{\code{current_buffer}}{Current playing buffer for seamless re-looping}

\item{\code{next_buffer}}{Pre-generated buffer for after transition}

\item{\code{section_cycle}}{Section types to cycle through for variety}

\item{\code{current_section_idx}}{Current position in section cycle
Manage buffer memory (prevent leaks)

Adds buffer to history and prunes old buffers to stay under max_buffer_seconds}
}
\if{html}{\out{</div>}}
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-PlaybackController-new}{\code{PlaybackController$new()}}
\item \href{#method-PlaybackController-generate_buffer}{\code{PlaybackController$generate_buffer()}}
\item \href{#method-PlaybackController-start}{\code{PlaybackController$start()}}
\item \href{#method-PlaybackController-stop}{\code{PlaybackController$stop()}}
\item \href{#method-PlaybackController-reload_script}{\code{PlaybackController$reload_script()}}
\item \href{#method-PlaybackController-queue_transition}{\code{PlaybackController$queue_transition()}}
\item \href{#method-PlaybackController-start_watching}{\code{PlaybackController$start_watching()}}
\item \href{#method-PlaybackController-stop_watching}{\code{PlaybackController$stop_watching()}}
\item \href{#method-PlaybackController-on_file_change}{\code{PlaybackController$on_file_change()}}
\item \href{#method-PlaybackController-get_state}{\code{PlaybackController$get_state()}}
\item \href{#method-PlaybackController-clone}{\code{PlaybackController$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PlaybackController-new"></a>}}
\if{latex}{\out{\hypertarget{method-PlaybackController-new}{}}}
\subsection{Method \code{new()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PlaybackController$new(
  script_path,
  bpm = NULL,
  genre = "deep_house",
  max_buffer_seconds = 300
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{script_path}}{Path to the R script to play}

\item{\code{bpm}}{Optional BPM (60-180). If NULL, auto-selects based on script hash.}

\item{\code{genre}}{Optional genre (deep_house, techno, ambient, drum_bass)}

\item{\code{max_buffer_seconds}}{Maximum total buffer seconds to keep in memory}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new PlaybackController instance
Generate Audio Buffer

Generates a 4-bar audio buffer using raver_compose_section().
Returns a Wave object ready for playback.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PlaybackController-generate_buffer"></a>}}
\if{latex}{\out{\hypertarget{method-PlaybackController-generate_buffer}{}}}
\subsection{Method \code{generate_buffer()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PlaybackController$generate_buffer(section_type = "drop", bars = 4L)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{section_type}}{Section type: "intro", "build", "drop", "breakdown", "outro"}

\item{\code{bars}}{Number of bars to generate. Default 4.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A tuneR Wave object containing the generated audio
Start Playback

Begins continuous playback. Generates a long buffer and loops it.
Only regenerates when file changes are detected.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PlaybackController-start"></a>}}
\if{latex}{\out{\hypertarget{method-PlaybackController-start}{}}}
\subsection{Method \code{start()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PlaybackController$start()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
NULL (invisibly)
Stop Playback

Stops playback immediately. Sets is_playing to FALSE, stops audio,
and clears any pending later() callbacks.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PlaybackController-stop"></a>}}
\if{latex}{\out{\hypertarget{method-PlaybackController-stop}{}}}
\subsection{Method \code{stop()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PlaybackController$stop()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
NULL (invisibly)
Reload Script

Re-analyzes the script file. On parse error, keeps last_known_good_model
and sets pending_transition for potential glitch effect. On success,
updates both code_model and last_known_good_model.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PlaybackController-reload_script"></a>}}
\if{latex}{\out{\hypertarget{method-PlaybackController-reload_script}{}}}
\subsection{Method \code{reload_script()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PlaybackController$reload_script()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Logical TRUE if reload succeeded, FALSE on parse error
Queue Transition

Marks a pending transition to be handled at the next phrase boundary.
This allows smooth transitions without abrupt audio changes.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PlaybackController-queue_transition"></a>}}
\if{latex}{\out{\hypertarget{method-PlaybackController-queue_transition}{}}}
\subsection{Method \code{queue_transition()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PlaybackController$queue_transition()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
NULL (invisibly)
Start File Watcher

Creates and starts a watcher for the script file. When the file changes,
on_file_change() is called to handle reloading and transition queueing.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PlaybackController-start_watching"></a>}}
\if{latex}{\out{\hypertarget{method-PlaybackController-start_watching}{}}}
\subsection{Method \code{start_watching()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PlaybackController$start_watching()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
NULL (invisibly)
Stop File Watcher

Stops the file watcher if it is running and cleans up the reference.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PlaybackController-stop_watching"></a>}}
\if{latex}{\out{\hypertarget{method-PlaybackController-stop_watching}{}}}
\subsection{Method \code{stop_watching()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PlaybackController$stop_watching()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
NULL (invisibly)
Handle File Change

Called by the watcher when file changes are detected. Checks if our
script is among the changed files and triggers reload/transition.
On parse error, sets has_parse_error flag for glitch effect generation.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PlaybackController-on_file_change"></a>}}
\if{latex}{\out{\hypertarget{method-PlaybackController-on_file_change}{}}}
\subsection{Method \code{on_file_change()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PlaybackController$on_file_change(changed_files)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{changed_files}}{Character vector of changed file paths}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
NULL (invisibly)
Get State

Returns current controller state for debugging and monitoring.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PlaybackController-get_state"></a>}}
\if{latex}{\out{\hypertarget{method-PlaybackController-get_state}{}}}
\subsection{Method \code{get_state()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PlaybackController$get_state()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
A list with current state information
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-PlaybackController-clone"></a>}}
\if{latex}{\out{\hypertarget{method-PlaybackController-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{PlaybackController$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
